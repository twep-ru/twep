---
title: Циклы и массивы
description: Как запускать JavaScript-код, объявлять переменные, выполнять числовые операции, выполнять строковые операции, использовать логические и математические операторы
---

# {{ $frontmatter.title}}

## Введение

Одной из задач программирования является повторение действий. Хотя некоторое ручное повторение допустимо, иногда мы хотим сделать повторяющиеся инструкции более читаемыми. Ещё одна проблема — работа с большими объемами данных. Например, если вы хотите сохранить имена всех студентов в вашей группе, как это сделать? Можно создать отдельную переменную для каждого имени, но такой подход будет утомительным и неэффективным. Также будет сложно управлять и обновлять такие данные. Что делать, если позже потребуется изменить или получить доступ к именам?

К счастью, существуют способы справиться с этими проблемами. В этом уроке вы узнаете о циклах — управляющих конструкциях, которые позволяют выполнять блок кода несколько раз. Вы также познакомитесь с массивами — структурами данных, способными хранить множество значений в одной переменной. Массивы очень полезны для организации и обработки больших объемов информации. Циклы часто оказываются удобным инструментом для выполнения одинаковых операций над каждым элементом массива. Наконец, вы познакомитесь с разработкой через тестирование (TDD) — практикой написания тестов для кода до того, как сам код будет написан.

## Обзор урока

Темы, которые вы изучите в данном уроке:

- Использование циклов.
- Использование массивов.
- Использование методов массивов, таких как `map`, `filter` и `reduce`.
- Практика в решении задач по TDD.

## Циклы

Компьютеры не устают, и они очень, очень быстры! Поэтому они отлично подходят для решения задач, связанных с многократным выполнением вычислений. В некоторых случаях компьютер может выполнить одну и ту же задачу тысячи или даже миллионы раз всего за несколько секунд, тогда как человеку это могло бы занять много часов (конечно, скорость зависит от сложности вычисления и производительности самого компьютера).

Чтобы повторить набор инструкций несколько раз, можно использовать **цикл**. Ознакомьтесь со следующими материалами о циклах. Некоторые из них содержат примеры с массивами, подробнее о которых пойдет речь в следующем разделе. Пока достаточно знать, что массивы — это просто списки элементов.

1. Прочитайте статью [MDN «Зацикливание кода»](https://developer.mozilla.org/ru/docs/Learn_web_development/Core/Scripting/Loops). Она довольно длинная, но обязательно пройдите разделы «Практическое упражнение» внизу страницы.
2. Еще раз те же сведения, но в немного другом контексте, можно найти в руководстве [Javascript.ru «Циклы: while и for»](https://learn.javascript.ru/while-for). Обязательно выполните упражнения в конце страницы. Лучше всего вы усваиваете материал, практикуясь самостоятельно.

## Массивы

Строки и числа могут быть нашими основными строительными блоками, но по мере усложнения ваших скриптов вам понадобится способ работы с большими объемами данных. К счастью, в JavaScript есть несколько типов данных, которые как раз для этого и предназначены. Массив представляет собой упорядоченную коллекцию элементов (строк, чисел или других объектов). Возможно, вы заметите, что некоторые из методов массива, описанных в следующих материалах, делают то же самое, что и циклы. Иногда для более точного управления лучше использовать обычный цикл, а иногда нужный результат можно достичь подходящим методом массива — это проще и удобнее читать.

1. Короткое видео [Ускоренный JS #5 - Массивы](https://vkvideo.ru/video-74984782_456240536) дает общее представление о массивах в JavaScript.
2. Ознакомьтесь с этим введением в массивы от [Javascript.ru](https://learn.javascript.ru/array). Вам не нужно выполнять упражнения в конце страницы.
3. Прочитайте руководство [Javascript.ru по методам массивов](https://learn.javascript.ru/array-methods), чтобы подробнее узнать о дополнительных методах массивов в JavaScript. Опять же, выполнять упражнения в конце страницы не обязательно — мы вернемся к ним позже.
4. Добавьте в закладки документацию MDN по [массивам](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array). Пока нет необходимости запоминать всё содержание. Здесь вы найдете описание всех встроенных свойств и методов массивов и их документации. Скорее всего, вы будете часто обращаться к этому ресурсу при написании кода и решении задач.

## Некоторые примеры «магии» массивов  

Кроме того, что массивы представляют собой удобный способ хранения данных, у них также есть множество встроенных функций для мощной и гибкой обработки этих данных. По мере накопления опыта вы начнете замечать, как часто можно использовать эти функции! На самом деле таких функций не так уж много, но, как вы скоро увидите, возможности, которые они открывают, почти безграничны.

В качестве примера рассмотрим функцию `sumOfTripledEvens` («сумма утроенных чётных чисел»). Она будет:

- Принимать массив.
- Для каждого чётного числа — утраивать его.
- Затем складывать все полученные числа.
Можете ли вы придумать, как реализовать такую функцию, используя псевдокод?

Нам нужно:
1. Выполнить операцию только над чётными числами.
2. Преобразовать эти числа, умножив их на 3.
3. В конце сложить результаты этого преобразования.

Используя эту логику, вы можете написать что-то подобное:

```javascript
function sumOfTripledEvens(array) {
  let sum = 0;
  for (let i = 0; i < array.length; i++) {
    // Шаг 1: Проверяем, является ли элемент чётным числом
    if (array[i] % 2 === 0) {
      // Шаг 2: Утраиваем это число
      const tripleEvenNumber = array[i] * 3;

      // Шаг 3: Добавляем новое число к общей сумме
      sum += tripleEvenNumber;
    }
  }
  return sum;
}
```

В приведённом выше коде есть три важных фрагмента:

- `if (array[i] % 2 === 0)` — проверяет, является ли число чётным.
- `const tripleEvenNumber = array[i] * 3` — утраивает число.
- `sum += tripleEvenNumber` — добавляет результат к общей сумме.

Каждая из этих строк решает важную задачу. Однако то же самое можно сделать с помощью методов массива, и иногда результат получается даже понятнее и легче для чтения. Давайте посмотрим, как мы можем воспользоваться ими.

### Метод `map`
`map` — это один из таких методов. Он принимает в качестве аргумента функцию обратного вызова (callback), другими словами — вы передаёте одну функцию внутрь другой.

Допустим, у нас есть функция `addOne`, которая принимает число `num` и возвращает его, увеличенное на единицу. Также у нас есть массив чисел `[1, 2, 3, 4, 5]`. И мы хотим увеличить каждое число в массиве на 1 с помощью этой функции.

Вместо того чтобы писать цикл `for` и перебирать массив вручную, мы можем воспользоваться методом `map`, который автоматически переберёт элементы за нас. Нам нужно лишь передать нужную функцию:

```javascript
function addOne(num) {
  return num + 1;
}

const arr = [1, 2, 3, 4, 5];
const mappedArr = arr.map(addOne);
console.log(mappedArr); // Выведет [2, 3, 4, 5, 6]
```

Метод `map` возвращает новый массив и **не изменяет** исходный массив.

```javascript
// Исходный массив не изменился!
console.log(arr); // Выведет [1, 2, 3, 4, 5]
```

Использование `map` может быть более элегантным решением по сравнению с написанием цикла. Но можно сделать ещё лучше! Если функция `addOne` используется только один раз и имеет простую логику, мы можем определить её прямо внутри метода `map` с помощью стрелочной функции:

```javascript
const arr = [1, 2, 3, 4, 5];
const mappedArr = arr.map((num) => num + 1);
console.log(mappedArr); // Выведет [2, 3, 4, 5, 6]
```

### Метод `filter`
Метод `filter` похож на `map`. Он тоже перебирает массив и применяет функцию ко всем его элементам. Однако вместо преобразования значений он создаёт новый массив, в который попадают только те элементы, для которых функция вернула `true`.

Предположим, у нас есть функция `isOdd`, которая возвращает `true`, если число нечётное, и `false` — если чётное.

Метод `filter` ожидает, что callback-функция вернёт `true` или `false`. Если возвращается `true`, элемент добавляется в новый массив. В противном случае — игнорируется.

Рассмотрим тот же массив `[1, 2, 3, 4, 5]`. Если мы хотим удалить все чётные числа, мы можем воспользоваться `.filter()` следующим образом:

```javascript
function isOdd(num) {
  return num % 2 !== 0;
}

const arr = [1, 2, 3, 4, 5];
const oddNums = arr.filter(isOdd);
console.log(oddNums); // Выведет [1, 3, 5]
console.log(arr); // Исходный массив остался неизменным: [1, 2, 3, 4, 5]
```

Метод `filter` перебирает массив `arr`, поочерёдно передавая каждый элемент в функцию `isOdd`.
Функция `isOdd` возвращает `true`, если число нечётное, и такой элемент включается в выходной массив.
Если число чётное, `isOdd` возвращает `false`, и элемент не включается в результат.