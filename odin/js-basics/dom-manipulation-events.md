---
title: Манипуляции с DOM и события
description: Что такое DOM, и как мы можем его изменять? Давайте разберемся…
---

# {{ $frontmatter.title}}

## Введение

Одной из самых уникальных и полезных возможностей JavaScript является возможность манипулировать DOM. Но что такое DOM, и как мы можем его изменять? Давайте разберемся…

## Обзор урока

<LessonOverview />

- Поймёте, что такое DOM в контексте веб-страницы.
- Поймёте разницу между «узлом» (node) и «элементом» (element).
- Поймёте, как обращаться к узлам с помощью «селекторов».
- Поймёте основные методы для поиска, добавления, удаления и изменения узлов DOM.
- Поймёте разницу между «NodeList» и «массивом узлов».
- Поймёте, что такое «всплытие событий» (bubbling) и как оно работает.

## Document Object Model

DOM (Document Object Model — Объектная модель документа) представляет собой древовидную структуру, отображающую содержимое веб-страницы — дерево «узлов» (nodes), отношения между которыми зависят от их расположения в HTML-документе. Существует множество типов узлов, большинство из которых редко используются. В этом уроке мы сосредоточимся на узлах типа «элемент» (element nodes), которые в основном применяются при работе с DOM.

```html
<div id="container">
  <div class="display"></div>
  <div class="controls"></div>
</div>
```

В приведённом выше примере элемент `<div class="display"></div>` является «дочерним» (child) элементу `<div id="container"></div>` и «соседним» (sibling) элементу `<div class="controls"></div>`. Представьте это как генеалогическое древо: `<div id="container"></div>` — родитель, а его дочерние элементы находятся на следующем уровне, каждый на своей «ветке».

## Обращение к узлам с помощью селекторов

При работе с DOM вы используете «селекторы», чтобы выбрать те узлы, с которыми хотите работать. Вы можете комбинировать селекторы в стиле CSS и свойства связей между элементами, чтобы точно указать нужные вам узлы. Начнём с селекторов в стиле CSS.

В предыдущем примере вы можете использовать следующие селекторы для обращения к элементу `<div class="display"></div>`:

- `div.display`
- `.display`
- `#container > .display`
- `div#container > div.display`

Также можно использовать относительные селекторы (например, `firstElementChild` или `lastElementChild` и т. д.) вместе со специальными свойствами, принадлежащими узлам.

```javascript
// выбирает div с id="container" (пока не беспокойтесь о синтаксисе, мы до него доберемся)
const container = document.querySelector("#container");

// выбирает первый дочерний элемент #container => .display
const display = container.firstElementChild;
console.log(display); // <div class="display"></div>
```

```javascript
// выбирает элемент .controls
const controls = document.querySelector(".controls");

// выбирает предыдущий соседний элемент => .display
const display = controls.previousElementSibling;
console.log(display); // <div class="display"></div>
```

Таким образом, вы определяете конкретный узел на основе его отношений с окружающими его узлами.

## Методы работы с DOM

Когда ваш HTML-код обрабатывается веб-браузером, он преобразуется в DOM, как уже упоминалось выше. Одно из основных отличий состоит в том, что эти узлы становятся объектами JavaScript, к которым прикреплено множество свойств и методов. Именно эти свойства и методы являются основными инструментами, которые мы будем использовать для манипуляций с веб-страницей через JavaScript.

**Селекторы запросов**

- `element.querySelector(selector)` — возвращает ссылку на первый найденный элемент, соответствующий указанному CSS-селектору.
- `element.querySelectorAll(selectors)` — возвращает «NodeList» со ссылками на все элементы, подходящие под указанные селекторы.

> Существуют и другие, более специфичные методы поиска, которые могут дать небольшой выигрыш в производительности, но сейчас мы их рассматривать не будем.

Важно помнить, что при использовании `querySelectorAll` результат **не является массивом**. Он может выглядеть как массив и вести себя почти как массив, но это на самом деле «NodeList». Основное отличие в том, что у NodeList отсутствуют некоторые методы, доступные у массивов. Если возникнут проблемы, можно преобразовать NodeList в массив. Это можно сделать с помощью `Array.from()` или оператора расширения (spread operator).

Пример:

```javascript
const nodeList = document.querySelectorAll("div");
const array = Array.from(nodeList);
// или
const array = [...nodeList];
```

**Создание элементов**

- `document.createElement(tagName, [options])` — создаёт новый элемент с указанным тегом `tagName`. Параметр `[options]` означает, что вы можете передать в функцию дополнительные параметры. На данном этапе не беспокойтесь об этом.

Пример:

```javascript
const div = document.createElement("div");
```

Эта функция **не добавляет** созданный элемент на страницу — она просто создаёт его в памяти. Это позволяет вам изменять элемент (добавлять стили, классы, id, текст и т.д.), прежде чем вставлять его на страницу. Для добавления элемента в DOM используются следующие методы.

**Добавление элементов**

- `parentNode.appendChild(childNode)` — добавляет `childNode` в качестве последнего дочернего элемента `parentNode`.
- `parentNode.insertBefore(newNode, referenceNode)` — вставляет `newNode` перед указанным `referenceNode` внутри `parentNode`.

**Удаление элементов**

- `parentNode.removeChild(child)` — удаляет `child` из `parentNode` в DOM и возвращает ссылку на удалённый элемент.

**Изменение элементов**

Когда у вас есть ссылка на элемент, вы можете использовать её, чтобы изменять собственные свойства этого элемента. Это позволяет выполнять множество полезных действий: добавлять, удалять или изменять атрибуты, менять классы, добавлять стили и многое другое.

```javascript
// создаёт новый div и сохраняет ссылку на него в переменной 'div'
const div = document.createElement("div");
```

**Добавление встроенных стилей (inline style)**

```javascript
// добавляет указанное CSS-свойство к элементу из переменной div
div.style.color = "blue";

// добавляет несколько CSS-свойств
div.style.cssText = "color: blue; background: white;";

// добавляет несколько CSS-свойств через setAttribute
div.setAttribute("style", "color: blue; background: white;");
```

При обращении к CSS-свойствам в стиле kebab-case (например, `background-color`) через JavaScript, необходимо использовать либо нотацию в стиле camelCase с точкой, либо квадратные скобки. При использовании квадратных скобок можно применять как kebab-case, так и camelCase, но имя свойства должно быть строкой.

```javascript
// нотация через точку с kebab-case: не работает, так как интерпретируется как вычитание
// эквивалентно: div.style.background - color
div.style.background - color; // ❌

// нотация через точку с camelCase: работает, обращается к стилю background-color
div.style.backgroundColor; // ✅

// нотация через квадратные скобки с kebab-case: также работает
div.style["background-color"]; // ✅

// нотация через квадратные скобки с camelCase: также работает
div.style["backgroundColor"]; // ✅
```

**Работа с атрибутами**

```javascript
// если id существует, обновляет его на 'theDiv', иначе создаёт атрибут id со значением "theDiv"
div.setAttribute("id", "theDiv");

// возвращает значение указанного атрибута, в данном случае "theDiv"
div.getAttribute("id");

// удаляет указанный атрибут
div.removeAttribute("id");
```

Более подробную информацию о доступных HTML-атрибутах вы можете найти в разделе [Справочная информация по HTML атрибутам](https://developer.mozilla.org/ru/docs/Web/HTML/Reference/Attributes) на MDN.

**Работа с классами**

```javascript
// добавляет класс "new" к вашему новому div
div.classList.add("new");

// удаляет класс "new" из div
div.classList.remove("new");

// если у div нет класса "active", добавляет его; если есть — удаляет
div.classList.toggle("active");
```

Часто рекомендуется использовать `classList.toggle()` для переключения CSS-классов, вместо добавления и удаления встроенных стилей. Это делает код чище и проще для управления через CSS.

**Добавление текстового содержимого**

```javascript
// создаёт текстовый узел с содержимым "Hello World!" и вставляет его в div
div.textContent = "Hello World!";
```

**Добавление HTML-содержимого**

```javascript
// рендерит HTML внутри div
div.innerHTML = "<span>Hello World!</span>";
```

> Обратите внимание, что при добавлении простого текста рекомендуется использовать `textContent` вместо `innerHTML`. Это связано с тем, что использование `innerHTML` может быть небезопасным и подверженным атакам. Чтобы понять риски, [посмотрите это видео](https://vkvideo.ru/video-223467206_456239078) о том, как предотвратить наиболее распространённые XSS-атаки.

**Обзор пройденного**

Давайте на минуту остановимся и повторим изученные материалы, чтобы вы могли попрактиковаться перед продолжением. Рассмотрим пример создания и добавления элемента DOM на веб-страницу.

```html
<!-- ваш HTML-файл: -->
<body>
  <h1>ЗАГОЛОВОК ВАШЕЙ СТРАНИЦЫ</h1>
  <div id="container"></div>
</body>
```

```javascript
// ваш JavaScript-файл:
const container = document.querySelector("#container");

const content = document.createElement("div");
content.classList.add("content");
content.textContent = "Это великолепный текст!";

container.appendChild(content);
```

В JavaScript-файле мы сначала получаем ссылку на существующий в HTML-элемент `<div id="container">`. Затем создаём новый `<div>`, сохраняем его в переменной `content`, добавляем этому элементу класс и текстовое содержимое, и, наконец, добавляем его внутрь контейнера.

После выполнения JavaScript наш DOM будет выглядеть так:

```html
<!-- DOM -->
<body>
  <h1>ЗАГОЛОВОК ВАШЕЙ СТРАНИЦЫ</h1>
  <div id="container">
    <div class="content">Это великолепный текст!</div>
  </div>
</body>
```

Важно понимать, что JavaScript **не изменяет ваш HTML-файл**, он изменяет только DOM — то, как браузер отображает страницу. Поэтому если вы откроете HTML-файл после выполнения кода, он останется неизменным.

> **Когда выполняется JavaScript**  
> JavaScript выполняется в момент загрузки файла или когда браузер встречает тег `<script>` в HTML. Если вы подключаете JavaScript в верхней части файла (например, в `<head>`), большинство методов манипуляции DOM работать не будут, потому что элементы ещё не созданы в DOM.  
> Самый простой способ избежать проблем — размещать тег `<script>` с JavaScript в конце HTML-файла, перед закрывающим тегом `</body>`. Тогда скрипт выполнится уже после того, как все элементы будут загружены.

> **Альтернатива: использование атрибута `defer`**  
> Вы также можете подключить JavaScript в разделе `<head>`, используя тег `<script>` с атрибутом `defer`. Это заставит браузер загрузить файл после разбора HTML, но до завершения загрузки изображений и других ресурсов.
> Пример:

```html
<head>
  <script src="js-file.js" defer></script>
</head>
```

> Более подробно об атрибуте `defer` можно узнать [javascript.ru](https://learn.javascript.ru/script-async-defer#defer).

## Практическое задание

Скопируйте приведённый выше пример в файлы на своём компьютере. Чтобы он работал, вам нужно создать полный HTML-файл и либо подключить JavaScript-файл, либо разместить код внутри тега `<script>` на странице. Убедитесь, что всё работает корректно, прежде чем переходить к следующему шагу!

Теперь с помощью **только JavaScript** и методов DOM, которые вы уже изучили, добавьте следующие элементы внутрь контейнера (`#container`):

1. Текстовый элемент `<p>`, окрашенный в красный цвет, с текстом «Hey I’m red!»
2. Заголовок `<h3>`, окрашенный в синий цвет, с текстом «I’m a blue h3!»
3. Элемент `<div>` с чёрной рамкой и розовым фоном, внутри которого находятся:
   - ещё один заголовок `<h1>` с текстом «I’m in a div»
   - текстовый элемент `<p>` с текстом «ME TOO!»
   - **Подсказка:** после создания `<div>` с помощью `createElement`, добавьте внутрь него `<h1>` и `<p>`, а уже затем вставляйте этот `<div>` в контейнер.

## События (Events)

Теперь, когда вы научились управлять DOM с помощью JavaScript, следующим важным шагом будет освоение динамического взаимодействия с элементами — то есть реакции на действия пользователя. Для этого используются **события**. Это действия, происходящие на вашей веб-странице: например, клики мышью, нажатия клавиш, движения курсора и другие.

С помощью JavaScript вы можете заставить вашу страницу "слушать" эти события и реагировать на них.

Есть **три основных способа** обработки событий:

1. Можно указывать функции прямо в HTML-атрибутах элементов.
2. Можно назначить свойства вида `on<eventType>` (например, `onclick`, `onmousedown`) для DOM-элементов в JavaScript.
3. Можно прикрепить **обработчики событий** (event listeners) к DOM-элементам с помощью JavaScript.

Наиболее предпочтительным является третий метод — использование **event listeners**, но вы часто будете встречать и первые два варианта в реальных проектах, поэтому давайте рассмотрим все три.

Создадим три кнопки, которые при клике показывают сообщение «Hello World». Вы можете попробовать их в своём HTML-файле или использовать онлайн-редактор вроде [CodePen](https://codepen.io/).

**Метод 1: через атрибут `onclick` в HTML**

```html
<button onclick="alert('Hello World')">Нажми меня</button>
```

Это решение не самое лучшее, потому что мы смешиваем HTML и JavaScript, делая код менее чистым и сложным для поддержки. К тому же, у каждого элемента может быть только одна функция, назначенная через `onclick`, поэтому таким способом нельзя выполнить несколько функций по одному клику.

**Метод 2: через свойство `onclick` в JavaScript**

```html
<!-- HTML-файл -->
<button id="btn">Нажми меня</button>
```

```javascript
// JavaScript-файл
const btn = document.querySelector("#btn");
btn.onclick = () => alert("Hello World");
```

Этот подход немного лучше: мы вынесли JavaScript из HTML. Однако ограничение остаётся: у элемента может быть только один обработчик события `onclick`. Если вы попытаетесь назначить ещё один — старый будет заменён.

> Если вы хотите освежить знания про стрелочные функции `() =>`, прочитайте статью о [стрелочных функциях в JavaScript](https://learn.javascript.ru/arrow-functions-basics).