---
title: Манипуляции с DOM и события
description: Что такое DOM, и как мы можем его изменять? Давайте разберемся…
---

# {{ $frontmatter.title}}

## Введение

Одной из самых уникальных и полезных возможностей JavaScript является возможность манипулировать DOM. Но что такое DOM, и как мы можем его изменять? Давайте разберемся…

## Обзор урока

<LessonOverview />

- Поймёте, что такое DOM в контексте веб-страницы.
- Поймёте разницу между «узлом» (node) и «элементом» (element).
- Поймёте, как обращаться к узлам с помощью «селекторов».
- Поймёте основные методы для поиска, добавления, удаления и изменения узлов DOM.
- Поймёте разницу между «NodeList» и «массивом узлов».
- Поймёте, что такое «всплытие событий» (bubbling) и как оно работает.

## Document Object Model

DOM (Document Object Model — Объектная модель документа) представляет собой древовидную структуру, отображающую содержимое веб-страницы — дерево «узлов» (nodes), отношения между которыми зависят от их расположения в HTML-документе. Существует множество типов узлов, большинство из которых редко используются. В этом уроке мы сосредоточимся на узлах типа «элемент» (element nodes), которые в основном применяются при работе с DOM.

```html
<div id="container">
  <div class="display"></div>
  <div class="controls"></div>
</div>
```

В приведённом выше примере элемент `<div class="display"></div>` является «дочерним» (child) элементу `<div id="container"></div>` и «соседним» (sibling) элементу `<div class="controls"></div>`. Представьте это как генеалогическое древо: `<div id="container"></div>` — родитель, а его дочерние элементы находятся на следующем уровне, каждый на своей «ветке».

## Обращение к узлам с помощью селекторов

При работе с DOM вы используете «селекторы», чтобы выбрать те узлы, с которыми хотите работать. Вы можете комбинировать селекторы в стиле CSS и свойства связей между элементами, чтобы точно указать нужные вам узлы. Начнём с селекторов в стиле CSS.

В предыдущем примере вы можете использовать следующие селекторы для обращения к элементу `<div class="display"></div>`:

- `div.display`
- `.display`
- `#container > .display`
- `div#container > div.display`

Также можно использовать относительные селекторы (например, `firstElementChild` или `lastElementChild` и т. д.) вместе со специальными свойствами, принадлежащими узлам.

```javascript
// выбирает div с id="container" (пока не беспокойтесь о синтаксисе, мы до него доберемся)
const container = document.querySelector("#container");

// выбирает первый дочерний элемент #container => .display
const display = container.firstElementChild;
console.log(display); // <div class="display"></div>
```

```javascript
// выбирает элемент .controls
const controls = document.querySelector(".controls");

// выбирает предыдущий соседний элемент => .display
const display = controls.previousElementSibling;
console.log(display); // <div class="display"></div>
```

Таким образом, вы определяете конкретный узел на основе его отношений с окружающими его узлами.

## Методы работы с DOM

Когда ваш HTML-код обрабатывается веб-браузером, он преобразуется в DOM, как уже упоминалось выше. Одно из основных отличий состоит в том, что эти узлы становятся объектами JavaScript, к которым прикреплено множество свойств и методов. Именно эти свойства и методы являются основными инструментами, которые мы будем использовать для манипуляций с веб-страницей через JavaScript.

**Селекторы запросов**

- `element.querySelector(selector)` — возвращает ссылку на первый найденный элемент, соответствующий указанному CSS-селектору.
- `element.querySelectorAll(selectors)` — возвращает «NodeList» со ссылками на все элементы, подходящие под указанные селекторы.

> Существуют и другие, более специфичные методы поиска, которые могут дать небольшой выигрыш в производительности, но сейчас мы их рассматривать не будем.

Важно помнить, что при использовании `querySelectorAll` результат **не является массивом**. Он может выглядеть как массив и вести себя почти как массив, но это на самом деле «NodeList». Основное отличие в том, что у NodeList отсутствуют некоторые методы, доступные у массивов. Если возникнут проблемы, можно преобразовать NodeList в массив. Это можно сделать с помощью `Array.from()` или оператора расширения (spread operator).

Пример:

```javascript
const nodeList = document.querySelectorAll("div");
const array = Array.from(nodeList);
// или
const array = [...nodeList];
```

**Создание элементов**

- `document.createElement(tagName, [options])` — создаёт новый элемент с указанным тегом `tagName`. Параметр `[options]` означает, что вы можете передать в функцию дополнительные параметры. На данном этапе не беспокойтесь об этом.

Пример:

```javascript
const div = document.createElement("div");
```

Эта функция **не добавляет** созданный элемент на страницу — она просто создаёт его в памяти. Это позволяет вам изменять элемент (добавлять стили, классы, id, текст и т.д.), прежде чем вставлять его на страницу. Для добавления элемента в DOM используются следующие методы.

**Добавление элементов**

- `parentNode.appendChild(childNode)` — добавляет `childNode` в качестве последнего дочернего элемента `parentNode`.
- `parentNode.insertBefore(newNode, referenceNode)` — вставляет `newNode` перед указанным `referenceNode` внутри `parentNode`.

**Удаление элементов**

- `parentNode.removeChild(child)` — удаляет `child` из `parentNode` в DOM и возвращает ссылку на удалённый элемент.

**Изменение элементов**

Когда у вас есть ссылка на элемент, вы можете использовать её, чтобы изменять собственные свойства этого элемента. Это позволяет выполнять множество полезных действий: добавлять, удалять или изменять атрибуты, менять классы, добавлять стили и многое другое.

```javascript
// создаёт новый div и сохраняет ссылку на него в переменной 'div'
const div = document.createElement("div");
```

**Добавление встроенных стилей (inline style)**

```javascript
// добавляет указанное CSS-свойство к элементу из переменной div
div.style.color = "blue";

// добавляет несколько CSS-свойств
div.style.cssText = "color: blue; background: white;";

// добавляет несколько CSS-свойств через setAttribute
div.setAttribute("style", "color: blue; background: white;");
```

При обращении к CSS-свойствам в стиле kebab-case (например, `background-color`) через JavaScript, необходимо использовать либо нотацию в стиле camelCase с точкой, либо квадратные скобки. При использовании квадратных скобок можно применять как kebab-case, так и camelCase, но имя свойства должно быть строкой.

```javascript
// нотация через точку с kebab-case: не работает, так как интерпретируется как вычитание
// эквивалентно: div.style.background - color
div.style.background - color; // ❌

// нотация через точку с camelCase: работает, обращается к стилю background-color
div.style.backgroundColor; // ✅

// нотация через квадратные скобки с kebab-case: также работает
div.style["background-color"]; // ✅

// нотация через квадратные скобки с camelCase: также работает
div.style["backgroundColor"]; // ✅
```

**Работа с атрибутами**

```javascript
// если id существует, обновляет его на 'theDiv', иначе создаёт атрибут id со значением "theDiv"
div.setAttribute("id", "theDiv");

// возвращает значение указанного атрибута, в данном случае "theDiv"
div.getAttribute("id");

// удаляет указанный атрибут
div.removeAttribute("id");
```

Более подробную информацию о доступных HTML-атрибутах вы можете найти в разделе [Справочная информация по HTML атрибутам](https://developer.mozilla.org/ru/docs/Web/HTML/Reference/Attributes) на MDN.

**Работа с классами**

```javascript
// добавляет класс "new" к вашему новому div
div.classList.add("new");

// удаляет класс "new" из div
div.classList.remove("new");

// если у div нет класса "active", добавляет его; если есть — удаляет
div.classList.toggle("active");
```

Часто рекомендуется использовать `classList.toggle()` для переключения CSS-классов, вместо добавления и удаления встроенных стилей. Это делает код чище и проще для управления через CSS.

**Добавление текстового содержимого**

```javascript
// создаёт текстовый узел с содержимым "Hello World!" и вставляет его в div
div.textContent = "Hello World!";
```

**Добавление HTML-содержимого**

```javascript
// рендерит HTML внутри div
div.innerHTML = "<span>Hello World!</span>";
```

> Обратите внимание, что при добавлении простого текста рекомендуется использовать `textContent` вместо `innerHTML`. Это связано с тем, что использование `innerHTML` может быть небезопасным и подверженным атакам. Чтобы понять риски, [посмотрите это видео](https://vkvideo.ru/video-223467206_456239078) о том, как предотвратить наиболее распространённые XSS-атаки.

**Обзор пройденного**

Давайте на минуту остановимся и повторим изученные материалы, чтобы вы могли попрактиковаться перед продолжением. Рассмотрим пример создания и добавления элемента DOM на веб-страницу.

```html
<!-- ваш HTML-файл: -->
<body>
  <h1>ЗАГОЛОВОК ВАШЕЙ СТРАНИЦЫ</h1>
  <div id="container"></div>
</body>
```

```javascript
// ваш JavaScript-файл:
const container = document.querySelector("#container");

const content = document.createElement("div");
content.classList.add("content");
content.textContent = "Это великолепный текст!";

container.appendChild(content);
```

В JavaScript-файле мы сначала получаем ссылку на существующий в HTML-элемент `<div id="container">`. Затем создаём новый `<div>`, сохраняем его в переменной `content`, добавляем этому элементу класс и текстовое содержимое, и, наконец, добавляем его внутрь контейнера.

После выполнения JavaScript наш DOM будет выглядеть так:

```html
<!-- DOM -->
<body>
  <h1>ЗАГОЛОВОК ВАШЕЙ СТРАНИЦЫ</h1>
  <div id="container">
    <div class="content">Это великолепный текст!</div>
  </div>
</body>
```

Важно понимать, что JavaScript **не изменяет ваш HTML-файл**, он изменяет только DOM — то, как браузер отображает страницу. Поэтому если вы откроете HTML-файл после выполнения кода, он останется неизменным.

> **Когда выполняется JavaScript**  
> JavaScript выполняется в момент загрузки файла или когда браузер встречает тег `<script>` в HTML. Если вы подключаете JavaScript в верхней части файла (например, в `<head>`), большинство методов манипуляции DOM работать не будут, потому что элементы ещё не созданы в DOM.  
> Самый простой способ избежать проблем — размещать тег `<script>` с JavaScript в конце HTML-файла, перед закрывающим тегом `</body>`. Тогда скрипт выполнится уже после того, как все элементы будут загружены.

> **Альтернатива: использование атрибута `defer`**  
> Вы также можете подключить JavaScript в разделе `<head>`, используя тег `<script>` с атрибутом `defer`. Это заставит браузер загрузить файл после разбора HTML, но до завершения загрузки изображений и других ресурсов.
> Пример:

```html
<head>
  <script src="js-file.js" defer></script>
</head>
```

> Более подробно об атрибуте `defer` можно узнать [javascript.ru](https://learn.javascript.ru/script-async-defer#defer).

## Практическое задание

Скопируйте приведённый выше пример в файлы на своём компьютере. Чтобы он работал, вам нужно создать полный HTML-файл и либо подключить JavaScript-файл, либо разместить код внутри тега `<script>` на странице. Убедитесь, что всё работает корректно, прежде чем переходить к следующему шагу!

Теперь с помощью **только JavaScript** и методов DOM, которые вы уже изучили, добавьте следующие элементы внутрь контейнера (`#container`):

1. Текстовый элемент `<p>`, окрашенный в красный цвет, с текстом «Hey I’m red!»
2. Заголовок `<h3>`, окрашенный в синий цвет, с текстом «I’m a blue h3!»
3. Элемент `<div>` с чёрной рамкой и розовым фоном, внутри которого находятся:
   - ещё один заголовок `<h1>` с текстом «I’m in a div»
   - текстовый элемент `<p>` с текстом «ME TOO!»
   - **Подсказка:** после создания `<div>` с помощью `createElement`, добавьте внутрь него `<h1>` и `<p>`, а уже затем вставляйте этот `<div>` в контейнер.

## События (Events)

Теперь, когда вы научились управлять DOM с помощью JavaScript, следующим важным шагом будет освоение динамического взаимодействия с элементами — то есть реакции на действия пользователя. Для этого используются **события**. Это действия, происходящие на вашей веб-странице: например, клики мышью, нажатия клавиш, движения курсора и другие.

С помощью JavaScript вы можете заставить вашу страницу "слушать" эти события и реагировать на них.

Есть **три основных способа** обработки событий:

1. Можно указывать функции прямо в HTML-атрибутах элементов.
2. Можно назначить свойства вида `on<eventType>` (например, `onclick`, `onmousedown`) для DOM-элементов в JavaScript.
3. Можно прикрепить **обработчики событий** (event listeners) к DOM-элементам с помощью JavaScript.

Наиболее предпочтительным является третий метод — использование **event listeners**, но вы часто будете встречать и первые два варианта в реальных проектах, поэтому давайте рассмотрим все три.

Создадим три кнопки, которые при клике показывают сообщение «Hello World». Вы можете попробовать их в своём HTML-файле или использовать онлайн-редактор вроде [CodePen](https://codepen.io/).

**Метод 1: через атрибут `onclick` в HTML**

```html
<button onclick="alert('Hello World')">Нажми меня</button>
```

Это решение не самое лучшее, потому что мы смешиваем HTML и JavaScript, делая код менее чистым и сложным для поддержки. К тому же, у каждого элемента может быть только одна функция, назначенная через `onclick`, поэтому таким способом нельзя выполнить несколько функций по одному клику.

**Метод 2: через свойство `onclick` в JavaScript**

```html
<!-- HTML-файл -->
<button id="btn">Нажми меня</button>
```

```javascript
// JavaScript-файл
const btn = document.querySelector("#btn");
btn.onclick = () => alert("Hello World");
```

Этот подход немного лучше: мы вынесли JavaScript из HTML. Однако ограничение остаётся: у элемента может быть только один обработчик события `onclick`. Если вы попытаетесь назначить ещё один — старый будет заменён.

> Если вы хотите освежить знания про стрелочные функции `() =>`, прочитайте статью о [стрелочных функциях в JavaScript](https://learn.javascript.ru/arrow-functions-basics).

**Метод 3: через `addEventListener`**

```html
<!-- HTML-файл -->
<button id="btn">Нажми меня тоже</button>
```

```javascript
// JavaScript-файл
const btn = document.querySelector("#btn");
btn.addEventListener("click", () => {
  alert("Hello World");
});
```

Теперь мы сохраняем разделение логики и структуры (принцип "separation of concerns"), и при этом можем добавить несколько обработчиков событий на один элемент, если это понадобится. Метод 3 является гораздо более гибким и мощным, хотя и немного сложнее в настройке.

Обратите внимание, что все три метода можно использовать с **именованными функциями**, например так:

**HTML-файл**
```html
<!-- Метод 1 -->
<button onclick="alertFunction()">НАЖМИ МЕНЯ</button>
```

```html
<!-- Методы 2 и 3 -->
<button id="btn">НАЖМИ МЕНЯ</button>
```

**JavaScript-файл**
```javascript
// Метод 1
function alertFunction() {
  alert("УРА! ТЫ СДЕЛАЛ ЭТО!");
}

// Методы 2 и 3
function alertFunction() {
  alert("УРА! ТЫ СДЕЛАЛ ЭТО!");
}

const btn = document.querySelector("#btn");

// Метод 2
btn.onclick = alertFunction;

// Метод 3
btn.addEventListener("click", alertFunction);
```

Использование именованных функций делает ваш код чище и понятнее. Это особенно полезно, если вы хотите вызывать одну и ту же функцию в разных частях кода.

С помощью всех трёх методов вы можете получить дополнительную информацию о событии, передав параметр в вашу функцию. Попробуйте этот код на своём компьютере:

```javascript
btn.addEventListener("click", function (e) {
  console.log(e);
});
```

> Когда вы передаёте `alertFunction` или `function (e) {...}` в `addEventListener`, вы используете **callback-функцию** — функцию, которая передаётся как аргумент в другую функцию.

Параметр `e` в этой функции содержит объект, связанный с самим событием. В этом объекте вы найдёте множество полезных свойств и методов: например, какая клавиша или кнопка мыши была нажата, а также информацию о **цели события** — DOM-элементе, на котором произошло событие.

> Обратите внимание: в названии `e` нет ничего особенного — это просто принятое сокращение от слова "event". JavaScript знает, что это событие, потому что callback обработчика событий по определению принимает объект события.

Когда вызывается callback, браузер передаёт в него ссылку на событие. Подробнее об объекте события вы можете узнать в [введении к событиям на MDN](https://developer.mozilla.org/ru/docs/Learn/JavaScript/Building_blocks/Events).

Попробуйте следующее:

```javascript
btn.addEventListener("click", function (e) {
  console.log(e.target);
});
```

А теперь это:

```javascript
btn.addEventListener("click", function (e) {
  e.target.style.background = "blue";
});
```

Круто, правда?

**Обработка событий для группы элементов**

Если вы добавляете одинаковые обработчики событий для множества элементов, это может показаться трудоёмким. Но есть способы сделать это эффективнее.

Мы уже знаем, что можем получить список элементов, соответствующих определённому селектору, с помощью `querySelectorAll('селектор')`. Чтобы добавить обработчик каждому элементу, нужно просто пройти по списку с помощью `.forEach`, как в этом примере:

```html
<div id="container">
  <button id="one">Нажми меня</button>
  <button id="two">Нажми меня</button>
  <button id="three">Нажми меня</button>
</div>
```

```javascript
// buttons — это NodeList. Он ведёт себя почти как массив.
const buttons = document.querySelectorAll("button");

// мы используем метод .forEach, чтобы пройти по каждому элементу
buttons.forEach((button) => {
  // и для каждой кнопки добавляем обработчик события 'click'
  button.addEventListener("click", () => {
    alert(button.id);
  });
});
```

Это лишь верхушка айсберга, когда речь заходит о манипуляциях с DOM и обработке событий. Но этих знаний уже достаточно, чтобы начать выполнять практические задания.

**Полезные типы событий**  

В наших примерах мы пока использовали только событие `click`, но на самом деле их гораздо больше. Вот некоторые из часто используемых:

- `click` — клик мышью
- `dblclick` — двойной клик
- `keydown` — нажатие клавиши
- `keyup` — отпускание клавиши

Более полный список событий с объяснениями вы найдёте на странице [Meliorem](http://meliorem.ru/frontend/javascript/spravochnik-javascript-sobytij-dom-elementov/).

## Задание

Манипуляция веб-страницами — это главное преимущество языка JavaScript! Как фронтенд-разработчик, вы будете использовать эти техники практически каждый день, так что давайте потренируемся!

1. Пройдите раздел [**Активное обучение: основы управления структурой DOM**](https://developer.mozilla.org/ru/docs/Learn_web_development/Core/Scripting/DOM_scripting) на сайте MDN, посвящённый манипуляциям с DOM, чтобы проверить свои навыки!
2. Ознакомьтесь с уроками по работе с DOM, чтобы понять, как использовать события на веб-страницах:
   - [Событийная модель](https://doka.guide/js/events/)
   - [Страница: DOMContentLoaded, load, beforeunload, unload](https://learn.javascript.ru/onload-ondomcontentloaded)
   - [События мыши](https://metanit.com/web/javascript/9.5.php)
   - [Клавиатура: keydown и keyup](https://learn.javascript.ru/keyboard-events)
   - [Простое объяснение делегирования событий в JavaScript](https://habr.com/ru/articles/512782/)
   - [Метод dispatchEvent](https://code.mu/ru/javascript/manual/event/dispatchEvent/)
   - [Пользовательские события в JavaScript: зачем нужны и как настроить](https://thecode.media/polzovatelskie-sobytiya-v-javascript-zachem-nuzhny-i-kak-nastroit/)

Обратите внимание, что некоторые методы, например `getElementById`, устарели и сегодня используются реже. Тем не менее, понимание их работы поможет вам лучше разобраться в основах.

Пока вы читаете, помните: общие принципы применимы к любым событиям, а специфическую информацию по конкретным типам событий всегда можно найти в документации.

## Проверьте себя

<LessonKnowledgeCheck />

**Что такое DOM?**  
<details>  
<summary>Ответ</summary>  

DOM (Document Object Model — Объектная модель документа) — это программный интерфейс (API), представляющий структуру HTML-документа в виде дерева узлов. Это позволяет JavaScript взаимодействовать с элементами страницы, изменять их и реагировать на действия пользователя.

</details>

**Как выбрать узлы, с которыми вы хотите работать?**  
<details>  
<summary>Ответ</summary>  

Для выбора узлов используются методы, такие как:  
- `document.querySelector()` — выбирает первый подходящий элемент по CSS-селектору.  
- `document.querySelectorAll()` — выбирает все подходящие элементы и возвращает NodeList.  
Также можно использовать свойства связи между узлами, например: `firstElementChild`, `lastElementChild`, `previousElementSibling`, `nextElementSibling`.

</details>

**Как создать новый элемент в DOM?**  
<details>  
<summary>Ответ</summary>  

Новый элемент создаётся с помощью метода:  
```javascript
const element = document.createElement("tag");
```
Например:  
```javascript
const div = document.createElement("div");
```

</details>

**Как добавить элемент в DOM?**  
<details>  
<summary>Ответ</summary>  

Элемент добавляется в DOM с помощью следующих методов:  
- `parentNode.appendChild(childNode)` — добавляет элемент как последний дочерний узел родителя.  
- `parentNode.insertBefore(newNode, referenceNode)` — добавляет элемент перед указанным узлом.

</details>

**Как удалить элемент из DOM?**  
<details>  
<summary>Ответ</summary>  

Элемент удаляется с помощью метода:  
```javascript
parentNode.removeChild(child);
```
Пример:  
```javascript
container.removeChild(div);
```

</details>

**Как изменить элемент в DOM?**  
<details>  
<summary>Ответ</summary>  

Элемент можно изменить следующими способами:  
- Изменение стиля: `element.style.property = value`  
- Добавление/удаление классов: `element.classList.add/remove/toggle("class")`  
- Установка атрибутов: `element.setAttribute("attr", "value")`  
- Изменение содержимого: `element.textContent` или `element.innerHTML`

</details>

**При добавлении текста в элемент DOM, что лучше использовать: textContent или innerHTML? Почему?**  
<details>  
<summary>Ответ</summary>  

Рекомендуется использовать `textContent`, потому что он безопаснее: он не интерпретирует HTML и предотвращает XSS-атаки. `innerHTML` позволяет вставлять HTML-разметку, но его следует использовать осторожно.

</details>

**Где в HTML-файле следует размещать тег `<script>` при работе с DOM?**  
<details>  
<summary>Ответ</summary>  

Скрипт лучше всего размещать в конце перед закрывающим тегом `</body>`, чтобы гарантировать, что весь DOM уже загружен. Либо можно использовать атрибут `defer` в теге `<script>` в разделе `<head>`.

</details>

**Как работают «события» и «обработчики событий»?**  
<details>  
<summary>Ответ</summary>  

События — это действия, происходящие в браузере (например, клик мыши, нажатие клавиши). Обработчики событий — это функции, которые вызываются при наступлении определённого события. С помощью них JavaScript может реагировать на действия пользователя.

</details>

**Какие три способа существуют для обработки событий в коде?**  
<details>  
<summary>Ответ</summary>  

1. Атрибуты событий в HTML: `<button onclick="myFunction()">Click</button>`  
2. Свойства DOM-элементов: `element.onclick = function`  
3. Использование `addEventListener`: `element.addEventListener("click", function)`

</details>

**Почему для обработки событий предпочтительнее использовать addEventListener?**  
<details>  
<summary>Ответ</summary>  

Метод `addEventListener` является наиболее гибким и предпочтительным, потому что:
- Позволяет добавлять несколько обработчиков на одно событие.
- Не перезаписывает существующие обработчики.
- Поддерживает параметры, такие как `useCapture` и возможность удаления слушателей.

</details>

**Каковы преимущества использования именованных функций в обработчиках событий?**  
<details>  
<summary>Ответ</summary>  

Именованные функции:
- Повторно используемы.
- Легче читаются и поддерживаются.
- Позволяют организовать логику вне обработчика события.

</details>

**Как прикрепить обработчики событий к группе элементов?**  
<details>  
<summary>Ответ</summary>  

Сначала получите список элементов с помощью `querySelectorAll()`, затем пройдитесь по нему циклом `.forEach()` и добавьте обработчик каждому элементу:

```javascript
document.querySelectorAll("button").forEach(button => {
  button.addEventListener("click", myFunction);
});
```

</details>

**В чём разница между результатами работы querySelector и querySelectorAll?**  
<details>  
<summary>Ответ</summary>  

- `querySelector()` возвращает **первый** совпадающий элемент.  
- `querySelectorAll()` возвращает **NodeList** всех совпадающих элементов.

</details>

**Что содержит NodeList?**  
<details>  
<summary>Ответ</summary>  

NodeList — это коллекция узлов (DOM-элементов), найденных по указанному селектору. Она похожа на массив, но не имеет всех его методов. Однако её можно преобразовать в массив с помощью `Array.from()` или spread-оператора `[...nodeList]`.

</details>

**В чём разница между «захватом события» (capture) и «всплытием» (bubbling)?**  
<details>  
<summary>Ответ</summary>  

- **Всплытие (bubbling)** — событие начинается с целевого элемента и поднимается вверх по дереву DOM (к родителям).  
- **Захват (capture)** — событие начинается с верхних элементов и движется вниз к целевому элементу.  
По умолчанию события обрабатываются на этапе всплытия. Чтобы обработать событие на этапе захвата, нужно указать `{ capture: true }` в `addEventListener`.

</details>

## Дополнительные материалы

<LessonAdditionalResources />

**Статьи и уроки**

- [Выразительный Javascript — Document Object Model](https://karmazzin.gitbook.io/eloquentjavascript_ru/chapter13)
- [Выразительный Javascript — Обработка событий](https://karmazzin.gitbook.io/eloquentjavascript_ru/chapter14)
- Раздел [Манипуляции с DOM](https://cheatsheets.super-mark.ru/) — шпаргалка с примерами кода по работе с DOM и другими аспектами JavaScript.
- [Что такое DOM и зачем он нужен?](https://itchief.ru/javascript/dom) — ещё одна статья, объясняющая основы DOM.
- [MDN — Введение в события](https://developer.mozilla.org/ru/docs/Learn/JavaScript/Building_blocks/Events) — подробное объяснение всех тем, связанных с событиями.
- [Создаём ударную установку на JS! #JavaScript30](https://vkvideo.ru/playlist/-223467206_4/video-223467206_456239038) — бесплатный видеокурс от Wes Bos, который поможет закрепить знания из этого урока. Обратите внимание: в видео используется устаревшее свойство `keyCode`, вместо него рекомендуется использовать `code`.
- [Захват, распространение и всплытие событий в JavaScript](https://vkvideo.ru/playlist/-223467206_4/video-223467206_456239063) — видео из #JavaScript30 от Wes Bos.
- [Callback функции в JavaScript: как работают, примеры использования](https://sky.pro/wiki/javascript/callback-funkcii-v-javascript-kak-rabotayut-primery-ispolzovaniya/) — объяснение callback-функций.

**Видео**

- [DOM JavaScript: стили и CSS-классы](https://www.youtube.com/playlist?list=PLillGF-RfqbbnEGyedXZaVvoYHT1OmzEk) — небольшое видео Александра Ламкова об основах DOM
- [Работа с DOM-деревом на JavaScript](https://rutube.ru/video/d556d75ce14dd9bd9a32132061cd18d5/?playlist=354866) — полноценный курс из 15 видеоуроков про работу JS в DOM
- [JavaScript Document object model (DOM) за час. Изменение HTML CSS. Атрибуты и свойства. Окружение.](https://vkvideo.ru/video-223467206_456239082)